#include <iostream>
#include <map>

using namespace std;

struct HFMNode
{
	char ch;
	int freq;
	HFMNode* left;
	HFMNode* right;
};

HFMNode* genHFMTree(map<char, int> letterFreq)
{
	HFMNode* globalRoot = NULL, * root, * tp1, * tp2;
	int minFreq;
	int minFreqNo[2];
	char minFreqLetter[2];
	bool EnWrite = false;
	if (!letterFreq.empty())//鍚﹀垯鏈夐鏈熶箣澶栫殑鎶ラ敊
		abort;
	while (!letterFreq.empty())
	{
		minFreq = INT_MAX;//璁� minFreg姣斾换浣曞嚱鏁板ぇ
		for (auto mapPointer = letterFreq.begin(); mapPointer != letterFreq.end(); mapPointer++)
		{
			if (minFreq > mapPointer->second)
			{
				minFreq = mapPointer->second;
				if (mapPointer->first != minFreqLetter[1])
				{
					minFreqNo[0] = mapPointer->second;
					minFreqLetter[0] = mapPointer->first;
				}
				if (!(letterFreq.size() == 3 && minFreqLetter[1] != NULL) && letterFreq.size() != 1)
					EnWrite = true;
			}
			if (EnWrite && next(mapPointer) != letterFreq.end())
				mapPointer++;
			if ((EnWrite && minFreq >= mapPointer->second))//涓哄噺灏戝帇缂╁悗绌洪棿
			{
				if (mapPointer->first != minFreqLetter[0])
				{
					minFreqNo[1] = mapPointer->second;
					minFreqLetter[1] = mapPointer->first;
				}
				EnWrite = false;
			}
			if (EnWrite && next(mapPointer) != letterFreq.end())
			{
				mapPointer--;
			}
		}
		tp1 = (HFMNode*)malloc(sizeof(HFMNode));
		tp1->ch = minFreqLetter[0];
		tp1->freq = minFreqNo[0];
		if (minFreqLetter[1] != NULL)
		{
			tp2 = (HFMNode*)malloc(sizeof(HFMNode));
			tp2->ch = minFreqLetter[1];
			tp2->freq = minFreqNo[1];
			//---//
			root = (HFMNode*)malloc(sizeof(HFMNode));
			root->left = tp1;
			root->right = tp2;
			root->freq = tp1->freq + tp2->freq;
			letterFreq.erase(minFreqLetter[1]);
			letterFreq.erase(minFreqLetter[0]);
			minFreqLetter[1] = NULL;
		}
		else
		{
			root = tp1;
			letterFreq.erase(minFreqLetter[0]);
		}
		if (globalRoot != NULL)
		{
			tp1 = globalRoot;//global root 鍊熶綅 temp pointer 1
			globalRoot = (HFMNode*)malloc(sizeof(HFMNode));
			globalRoot->left = root;
			globalRoot->right = tp1;
			globalRoot->freq = globalRoot->left->freq + globalRoot->right->freq;
			letterFreq.erase(minFreqLetter[0]);
			letterFreq.erase(minFreqLetter[1]);
		}
		else
		{
			globalRoot = root;
		}
	}
	return globalRoot;
}

string pressDict(char target, string route, HFMNode* dict)
{
	string returnRoute;
	if (dict->ch == target)
			return route;
	if (dict->left != NULL)
		returnRoute = pressDict(target, route, dict->left);
	if (dict->right != NULL)
		returnRoute = pressDict(target, returnRoute, dict->right);
	if (route != returnRoute && dict->left != NULL && dict->right != NULL)//鎵惧埌&涓嶆槸鍙跺瓙
		return returnRoute; 
	route.erase(route.end()-1); //鎵句笉鍒皘|鏄彾瀛�
	return route;
}

string compress(string text, HFMNode* dict)
{
	string pressText = "";
	char * buf = new char [text.size()-1];
	pressText = pressText;
	return pressText;
}

int main()
{
	string text = "The Chinese official said he viewed the Trump Presidency not as an aberration but as the product of a failing political system. This jibes with other accounts. The Chinese leadership believes that the United States, and Western democracies in general, haven鈥檛 risen to the challenge of a globalized economy, which necessitates big changes in production patterns, as well as major upgrades in education and public infrastructure. In Trump and Trumpism, the Chinese see an inevitable backlash to this failure.";
	string r;
	map<char, int>letterFreq;//鑾峰緱瀛楁瘝棰戠巼
	for (char letter : text)
		letterFreq[letter]++;
	HFMNode* root = genHFMTree(letterFreq);
	pressDict('e', r , root);
}
